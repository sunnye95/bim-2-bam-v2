{
  "version": 3,
  "sources": ["../../node_modules/@arc-web/components/dist/components/icon/constants/IconConstants.js", "../../node_modules/lit-html/src/directives/if-defined.ts", "../../node_modules/@arc-web/components/dist/utilities/base-path.js", "../../node_modules/lit-html/src/static.ts", "../../node_modules/lit-html/src/directives/when.ts", "../../node_modules/@arc-web/components/dist/components/icon-button/arc-icon-button.styles.js", "../../node_modules/lit-html/src/directives/style-map.ts", "../../node_modules/@arc-web/components/dist/internal/constants/styleConstants.js", "../../node_modules/@arc-web/components/dist/components/icon/arc-icon.styles.js", "../../node_modules/@arc-web/components/dist/components/icon/ArcIcon.js", "../../node_modules/@arc-web/components/dist/components/icon/arc-icon.js", "../../node_modules/@arc-web/components/dist/components/spinner/arc-spinner.styles.js", "../../node_modules/@arc-web/components/dist/components/spinner/ArcSpinner.js", "../../node_modules/@arc-web/components/dist/components/spinner/arc-spinner.js", "../../node_modules/@arc-web/components/dist/components/icon-button/ArcIconButton.js", "../../node_modules/@arc-web/components/dist/components/icon-button/arc-icon-button.js", "../../node_modules/tabbable/src/index.js", "../../node_modules/@arc-web/components/dist/internal/tabbable.js"],
  "sourcesContent": ["export const ICON_TYPES = {\n    'music-tone-alt': 'music-tone-alt',\n    rocket: 'rocket',\n    'cup-2': 'cup-2',\n    drawer: 'drawer',\n    'folder-alt': 'folder-alt',\n    pin: 'pin',\n    chemistry: 'chemistry',\n    shield: 'shield',\n    'game-controller': 'game-controller',\n    plane: 'plane',\n    organization: 'organization',\n    'call-end': 'call-end',\n    'call-in': 'call-in',\n    'call-out': 'call-out',\n    camrecorder: 'camrecorder',\n    bag: 'bag',\n    umbrella: 'umbrella',\n    basket: 'basket',\n    'basket-loaded': 'basket-loaded',\n    calculator: 'calculator',\n    cup: 'cup',\n    earphones: 'earphones',\n    'earphones-alt': 'earphones-alt',\n    handbag: 'handbag',\n    wallet: 'wallet',\n    present: 'present',\n    badge: 'badge',\n    eyeglass: 'eyeglass',\n    graduation: 'graduation',\n    mouse: 'mouse',\n    speedometer: 'speedometer',\n    graph: 'graph',\n    clock: 'clock',\n    wrench: 'wrench',\n    'volume-2': 'volume-2',\n    vector: 'vector',\n    'arrow-down': 'arrow-down',\n    anchor: 'anchor',\n    'action-undo': 'action-undo',\n    'action-redo': 'action-redo',\n    accessibility: 'accessibility',\n    'user-following': 'user-following',\n    'volume-off': 'volume-off',\n    support: 'support',\n    'volume-1': 'volume-1',\n    user: 'user',\n    'user-unfollow': 'user-unfollow',\n    'user-follow': 'user-follow',\n    'user-female': 'user-female',\n    'share-alt': 'share-alt',\n    trash: 'trash',\n    target: 'target',\n    'question-circle': 'question-circle',\n    tag: 'tag',\n    star: 'star',\n    'screen-tablet': 'screen-tablet',\n    speech: 'speech',\n    'size-fullscreen': 'size-fullscreen',\n    'size-actual': 'size-actual',\n    shuffle: 'shuffle',\n    power: 'power',\n    share: 'share',\n    settings: 'settings',\n    picture: 'picture',\n    'screen-smartphone': 'screen-smartphone',\n    'screen-desktop': 'screen-desktop',\n    satellite: 'satellite',\n    reload: 'reload',\n    refresh: 'refresh',\n    magnifier: 'magnifier',\n    puzzle: 'puzzle',\n    printer: 'printer',\n    login: 'login',\n    'plus-circle': 'plus-circle',\n    'pie-chart': 'pie-chart',\n    'options-vertical': 'options-vertical',\n    people: 'people',\n    pencil: 'pencil',\n    'paper-plane': 'paper-plane',\n    heart: 'heart',\n    options: 'options',\n    notebook: 'notebook',\n    note: 'note',\n    'music-tone': 'music-tone',\n    'minus-circle': 'minus-circle',\n    microphone: 'microphone',\n    menu: 'menu',\n    map: 'map',\n    like: 'like',\n    loop: 'loop',\n    logout: 'logout',\n    'cursor-move': 'cursor-move',\n    'lock-open': 'lock-open',\n    lock: 'lock',\n    'location-pin': 'location-pin',\n    list: 'list',\n    link: 'link',\n    folder: 'folder',\n    layers: 'layers',\n    key: 'key',\n    'info-circle': 'info-circle',\n    hourglass: 'hourglass',\n    home: 'home',\n    film: 'film',\n    grid: 'grid',\n    'globe-alt': 'globe-alt',\n    globe: 'globe',\n    frame: 'frame',\n    crop: 'crop',\n    flag: 'flag',\n    fire: 'fire',\n    energy: 'energy',\n    feed: 'feed',\n    eye: 'eye',\n    'exclamation-circle': 'exclamation-circle',\n    event: 'event',\n    equalizer: 'equalizer',\n    'envelope-open': 'envelope-open',\n    'envelope-letter': 'envelope-letter',\n    envelope: 'envelope',\n    directions: 'directions',\n    docs: 'docs',\n    doc: 'doc',\n    dislike: 'dislike',\n    'control-play': 'control-play',\n    direction: 'direction',\n    'close-circle': 'close-circle',\n    cursor: 'cursor',\n    'arrow-left': 'arrow-left',\n    'control-start': 'control-start',\n    'control-rewind': 'control-rewind',\n    camera: 'camera',\n    'control-pause': 'control-pause',\n    'control-forward': 'control-forward',\n    'control-end': 'control-end',\n    compass: 'compass',\n    'cloud-upload': 'cloud-upload',\n    'cloud-download': 'cloud-download',\n    'arrow-up-circle': 'arrow-up-circle',\n    x: 'x',\n    'check-circle': 'check-circle',\n    chart: 'chart',\n    calendar: 'calendar',\n    bulb: 'bulb',\n    bubbles: 'bubbles',\n    bubble: 'bubble',\n    briefcase: 'briefcase',\n    'book-open': 'book-open',\n    'arrow-right': 'arrow-right',\n    bell: 'bell',\n    'ban-circle': 'ban-circle',\n    'arrow-left-circle': 'arrow-left-circle',\n    'arrow-up': 'arrow-up',\n    'arrow-right-circle': 'arrow-right-circle',\n    'arrow-down-circle': 'arrow-down-circle',\n};\n", "/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {nothing} from '../lit-html.js';\n\n/**\n * For AttributeParts, sets the attribute if the value is defined and removes\n * the attribute if the value is undefined.\n *\n * For other part types, this directive is a no-op.\n */\nexport const ifDefined = <T>(value: T) => value ?? nothing;\n", "let basePath = '';\nfunction setBasePath(path) {\n    basePath = path;\n}\nfunction getBasePath() {\n    return basePath.replace(/\\/$/, '');\n}\nexport { setBasePath, getBasePath };\nconst scripts = [...document.getElementsByTagName('script')];\nconst configScript = scripts.find(script => script.hasAttribute('data-arc'));\nif (configScript) {\n    setBasePath(configScript.getAttribute('data-arc'));\n}\nelse {\n    const fallbackScript = scripts.find(s => /arc(\\.min)?\\.js$/.test(s.src));\n    let path = '';\n    if (fallbackScript) {\n        path = fallbackScript.getAttribute('src');\n    }\n    setBasePath(path.split('/').slice(0, -1).join('/'));\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n// Any new exports need to be added to the export statement in\n// `packages/lit/src/index.all.ts`.\n\nimport {html as coreHtml, svg as coreSvg, TemplateResult} from './lit-html.js';\n\nexport interface StaticValue {\n  /** The value to interpolate as-is into the template. */\n  _$litStatic$: string;\n\n  /**\n   * A value that can't be decoded from ordinary JSON, make it harder for\n   * a attacker-controlled data that goes through JSON.parse to produce a valid\n   * StaticValue.\n   */\n  r: typeof brand;\n}\n\n/**\n * Prevents JSON injection attacks.\n *\n * The goals of this brand:\n *   1) fast to check\n *   2) code is small on the wire\n *   3) multiple versions of Lit in a single page will all produce mutually\n *      interoperable StaticValues\n *   4) normal JSON.parse (without an unusual reviver) can not produce a\n *      StaticValue\n *\n * Symbols satisfy (1), (2), and (4). We use Symbol.for to satisfy (3), but\n * we don't care about the key, so we break ties via (2) and use the empty\n * string.\n */\nconst brand = Symbol.for('');\n\n/** Safely extracts the string part of a StaticValue. */\nconst unwrapStaticValue = (value: unknown): string | undefined => {\n  if ((value as Partial<StaticValue>)?.r !== brand) {\n    return undefined;\n  }\n  return (value as Partial<StaticValue>)?.['_$litStatic$'];\n};\n\n/**\n * Wraps a string so that it behaves like part of the static template\n * strings instead of a dynamic value.\n *\n * Users must take care to ensure that adding the static string to the template\n * results in well-formed HTML, or else templates may break unexpectedly.\n *\n * Note that this function is unsafe to use on untrusted content, as it will be\n * directly parsed into HTML. Do not pass user input to this function\n * without sanitizing it.\n *\n * Static values can be changed, but they will cause a complete re-render\n * since they effectively create a new template.\n */\nexport const unsafeStatic = (value: string): StaticValue => ({\n  ['_$litStatic$']: value,\n  r: brand,\n});\n\nconst textFromStatic = (value: StaticValue) => {\n  if (value['_$litStatic$'] !== undefined) {\n    return value['_$litStatic$'];\n  } else {\n    throw new Error(\n      `Value passed to 'literal' function must be a 'literal' result: ${value}. Use 'unsafeStatic' to pass non-literal values, but\n            take care to ensure page security.`\n    );\n  }\n};\n\n/**\n * Tags a string literal so that it behaves like part of the static template\n * strings instead of a dynamic value.\n *\n * The only values that may be used in template expressions are other tagged\n * `literal` results or `unsafeStatic` values (note that untrusted content\n * should never be passed to `unsafeStatic`).\n *\n * Users must take care to ensure that adding the static string to the template\n * results in well-formed HTML, or else templates may break unexpectedly.\n *\n * Static values can be changed, but they will cause a complete re-render since\n * they effectively create a new template.\n */\nexport const literal = (\n  strings: TemplateStringsArray,\n  ...values: unknown[]\n): StaticValue => ({\n  ['_$litStatic$']: values.reduce(\n    (acc, v, idx) => acc + textFromStatic(v as StaticValue) + strings[idx + 1],\n    strings[0]\n  ) as string,\n  r: brand,\n});\n\nconst stringsCache = new Map<string, TemplateStringsArray>();\n\n/**\n * Wraps a lit-html template tag (`html` or `svg`) to add static value support.\n */\nexport const withStatic =\n  (coreTag: typeof coreHtml | typeof coreSvg) =>\n  (strings: TemplateStringsArray, ...values: unknown[]): TemplateResult => {\n    const l = values.length;\n    let staticValue: string | undefined;\n    let dynamicValue: unknown;\n    const staticStrings: Array<string> = [];\n    const dynamicValues: Array<unknown> = [];\n    let i = 0;\n    let hasStatics = false;\n    let s: string;\n\n    while (i < l) {\n      s = strings[i];\n      // Collect any unsafeStatic values, and their following template strings\n      // so that we treat a run of template strings and unsafe static values as\n      // a single template string.\n      while (\n        i < l &&\n        ((dynamicValue = values[i]),\n        (staticValue = unwrapStaticValue(dynamicValue))) !== undefined\n      ) {\n        s += staticValue + strings[++i];\n        hasStatics = true;\n      }\n      // If the last value is static, we don't need to push it.\n      if (i !== l) {\n        dynamicValues.push(dynamicValue);\n      }\n      staticStrings.push(s);\n      i++;\n    }\n    // If the last value isn't static (which would have consumed the last\n    // string), then we need to add the last string.\n    if (i === l) {\n      staticStrings.push(strings[l]);\n    }\n\n    if (hasStatics) {\n      const key = staticStrings.join('$$lit$$');\n      strings = stringsCache.get(key)!;\n      if (strings === undefined) {\n        // Beware: in general this pattern is unsafe, and doing so may bypass\n        // lit's security checks and allow an attacker to execute arbitrary\n        // code and inject arbitrary content.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (staticStrings as any).raw = staticStrings;\n        stringsCache.set(\n          key,\n          (strings = staticStrings as unknown as TemplateStringsArray)\n        );\n      }\n      values = dynamicValues;\n    }\n    return coreTag(strings, ...values);\n  };\n\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n *\n * Includes static value support from `lit-html/static.js`.\n */\nexport const html = withStatic(coreHtml);\n\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n *\n * Includes static value support from `lit-html/static.js`.\n */\nexport const svg = withStatic(coreSvg);\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * When `condition` is true, returns the result of calling `trueCase()`, else\n * returns the result of calling `falseCase()` if `falseCase` is defined.\n *\n * This is a convenience wrapper around a ternary expression that makes it a\n * little nicer to write an inline conditional without an else.\n *\n * @example\n *\n * ```ts\n * render() {\n *   return html`\n *     ${when(this.user, () => html`User: ${this.user.username}`, () => html`Sign In...`)}\n *   `;\n * }\n * ```\n */\nexport function when<T, F>(\n  condition: true,\n  trueCase: () => T,\n  falseCase?: () => F\n): T;\nexport function when<T, F = undefined>(\n  condition: false,\n  trueCase: () => T,\n  falseCase?: () => F\n): F;\nexport function when<T, F = undefined>(\n  condition: unknown,\n  trueCase: () => T,\n  falseCase?: () => F\n): T | F;\nexport function when(\n  condition: unknown,\n  trueCase: () => unknown,\n  falseCase?: () => unknown\n): unknown {\n  return condition ? trueCase() : falseCase?.();\n}\n", "import { css } from 'lit';\nimport componentStyles from '../../styles/component.styles.js';\nexport default [\n    componentStyles,\n    css `\n    :host {\n      display: inline-flex;\n      cursor: pointer;\n      --icon-color: rgb(var(--arc-font-color));\n    }\n\n    .button {\n      display: grid;\n      align-content: center;\n      text-align: center;\n      width: 100%;\n      min-height: 100%;\n      border: none;\n      font-family: var(--arc-font-button);\n      line-height: inherit;\n      text-decoration: none;\n      user-select: none;\n      white-space: nowrap;\n      vertical-align: middle;\n      padding: 0;\n      cursor: inherit;\n      color: var(--icon-color);\n      background: none;\n      outline: none;\n      -webkit-appearance: none;\n    }\n\n    #iconWrapper {\n      display: flex;\n      justify-content: center;\n      align-items: center;\n    }\n\n    #icon {\n      padding: var(--arc-spacing-small);\n      border-radius: 50%;\n    }\n\n    #action {\n      font-size: var(--arc-font-size-xx-small);\n      margin-top: -0.2rem;\n    }\n\n    /* Active */\n    .button.button--active {\n      border-bottom: calc(var(--arc-border-width) * 2) var(--arc-border-style) currentColor;\n    }\n\n    /* Hover, Focus & Mouse down */\n    .button:hover:not(.button--disabled):not(.button--loading) #icon,\n    .button:focus-visible:not(.button--disabled):not(.button--loading) #icon {\n      background-color: rgba(var(--arc-font-color), 10%);\n    }\n    .button:active:not(.button--disabled):not(.button--loading) #icon {\n      background-color: rgba(var(--arc-font-color), 30%);\n    }\n\n    /* Disabled */\n    .button--disabled {\n      opacity: 0.5;\n      cursor: not-allowed;\n    }\n\n    /* Loading */\n    .button--loading {\n      cursor: wait;\n    }\n\n    .button--loading #icon {\n      visibility: hidden;\n    }\n\n    #loader {\n      position: absolute;\n    }\n\n    /* Prevent click events from firing on slots */\n    #iconWrapper,\n    #icon,\n    #action {\n      pointer-events: none;\n    }\n  `,\n];\n", "/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {AttributePart, noChange} from '../lit-html.js';\nimport {\n  directive,\n  Directive,\n  DirectiveParameters,\n  PartInfo,\n  PartType,\n} from '../directive.js';\n\n/**\n * A key-value set of CSS properties and values.\n *\n * The key should be either a valid CSS property name string, like\n * `'background-color'`, or a valid JavaScript camel case property name\n * for CSSStyleDeclaration like `backgroundColor`.\n */\nexport interface StyleInfo {\n  [name: string]: string | number | undefined | null;\n}\n\nconst important = 'important';\n// The leading space is important\nconst importantFlag = ' !' + important;\n// How many characters to remove from a value, as a negative number\nconst flagTrim = 0 - importantFlag.length;\n\nclass StyleMapDirective extends Directive {\n  _previousStyleProperties?: Set<string>;\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (\n      partInfo.type !== PartType.ATTRIBUTE ||\n      partInfo.name !== 'style' ||\n      (partInfo.strings?.length as number) > 2\n    ) {\n      throw new Error(\n        'The `styleMap` directive must be used in the `style` attribute ' +\n          'and must be the only part in the attribute.'\n      );\n    }\n  }\n\n  render(styleInfo: Readonly<StyleInfo>) {\n    return Object.keys(styleInfo).reduce((style, prop) => {\n      const value = styleInfo[prop];\n      if (value == null) {\n        return style;\n      }\n      // Convert property names from camel-case to dash-case, i.e.:\n      //  `backgroundColor` -> `background-color`\n      // Vendor-prefixed names need an extra `-` appended to front:\n      //  `webkitAppearance` -> `-webkit-appearance`\n      // Exception is any property name containing a dash, including\n      // custom properties; we assume these are already dash-cased i.e.:\n      //  `--my-button-color` --> `--my-button-color`\n      prop = prop.includes('-')\n        ? prop\n        : prop\n            .replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, '-$&')\n            .toLowerCase();\n      return style + `${prop}:${value};`;\n    }, '');\n  }\n\n  override update(part: AttributePart, [styleInfo]: DirectiveParameters<this>) {\n    const {style} = part.element as HTMLElement;\n\n    if (this._previousStyleProperties === undefined) {\n      this._previousStyleProperties = new Set();\n      for (const name in styleInfo) {\n        this._previousStyleProperties.add(name);\n      }\n      return this.render(styleInfo);\n    }\n\n    // Remove old properties that no longer exist in styleInfo\n    // We use forEach() instead of for-of so that re don't require down-level\n    // iteration.\n    this._previousStyleProperties!.forEach((name) => {\n      // If the name isn't in styleInfo or it's null/undefined\n      if (styleInfo[name] == null) {\n        this._previousStyleProperties!.delete(name);\n        if (name.includes('-')) {\n          style.removeProperty(name);\n        } else {\n          // Note reset using empty string (vs null) as IE11 does not always\n          // reset via null (https://developer.mozilla.org/en-US/docs/Web/API/ElementCSSInlineStyle/style#setting_styles)\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (style as any)[name] = '';\n        }\n      }\n    });\n\n    // Add or update properties\n    for (const name in styleInfo) {\n      const value = styleInfo[name];\n      if (value != null) {\n        this._previousStyleProperties.add(name);\n        const isImportant =\n          typeof value === 'string' && value.endsWith(importantFlag);\n        if (name.includes('-') || isImportant) {\n          style.setProperty(\n            name,\n            isImportant\n              ? (value as string).slice(0, flagTrim)\n              : (value as string),\n            isImportant ? important : ''\n          );\n        } else {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (style as any)[name] = value;\n        }\n      }\n    }\n    return noChange;\n  }\n}\n\n/**\n * A directive that applies CSS properties to an element.\n *\n * `styleMap` can only be used in the `style` attribute and must be the only\n * expression in the attribute. It takes the property names in the\n * {@link StyleInfo styleInfo} object and adds the properties to the inline\n * style of the element.\n *\n * Property names with dashes (`-`) are assumed to be valid CSS\n * property names and set on the element's style object using `setProperty()`.\n * Names without dashes are assumed to be camelCased JavaScript property names\n * and set on the element's style object using property assignment, allowing the\n * style object to translate JavaScript-style names to CSS property names.\n *\n * For example `styleMap({backgroundColor: 'red', 'border-top': '5px', '--size':\n * '0'})` sets the `background-color`, `border-top` and `--size` properties.\n *\n * @param styleInfo\n * @see {@link https://lit.dev/docs/templates/directives/#stylemap styleMap code samples on Lit.dev}\n */\nexport const styleMap = directive(StyleMapDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {StyleMapDirective};\n", "export const FONT_SIZES = {\n    'xx-small': 'xx-small',\n    'x-small': 'x-small',\n    small: 'small',\n    medium: 'medium',\n    large: 'large',\n    'x-large': 'x-large',\n    'xx-large': 'xx-large',\n    'xxx-large': 'xxx-large',\n    'xxxx-large': 'xxxx-large',\n};\nexport const FONT_SPACING = {\n    dense: 'dense',\n    normal: 'normal',\n    loose: 'loose',\n};\nexport const INPUT_SIZES = {\n    small: 'small',\n    medium: 'medium',\n    large: 'large',\n};\nexport const THEME_COLORS = {\n    default: 'default',\n    primary: 'primary',\n    secondary: 'secondary',\n    error: 'error',\n    warning: 'warning',\n    info: 'info',\n    success: 'success',\n};\n", "import { css } from 'lit';\nimport componentStyles from '../../styles/component.styles.js';\nexport default [\n    componentStyles,\n    css `\n    :host {\n      display: inline-flex;\n      --icon-color-primary: inherit;\n      --icon-color-secondary: currentColor;\n    }\n\n    #main {\n      display: block;\n      color: var(--icon-color-primary);\n      line-height: 1;\n      flex-shrink: 0;\n      max-width: initial;\n    }\n\n    #main use {\n      fill: var(--icon-color-secondary);\n      stroke: var(--icon-color-secondary);\n      --icon-stroke-linecap-butt: butt;\n      stroke-miterlimit: 10;\n      stroke-linecap: square;\n      stroke-linejoin: miter;\n    }\n  `,\n];\n", "import { __decorate } from \"tslib\";\nimport { html, LitElement } from 'lit';\nimport { property } from 'lit/decorators.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { styleMap } from 'lit/directives/style-map.js';\nimport { getBasePath } from '../../utilities/base-path.js';\nimport { ICON_TYPES } from './constants/IconConstants.js';\nimport { FONT_SIZES } from '../../internal/constants/styleConstants.js';\nimport styles from './arc-icon.styles.js';\nexport default class ArcIcon extends LitElement {\n    constructor() {\n        super(...arguments);\n        this.name = ICON_TYPES.fire;\n        this.size = FONT_SIZES.medium;\n        this.rotation = 0;\n    }\n    render() {\n        const DEFAULT_PATH = `${getBasePath()}/assets/icons.svg`;\n        const iconStyles = {\n            transform: this.rotation ? `rotate(${this.rotation}deg)` : null,\n            height: `var(--arc-font-size-${this.size})`,\n            width: `var(--arc-font-size-${this.size})`,\n        };\n        return html `\n      <svg\n        id=\"main\"\n        style=${styleMap(iconStyles)}\n        role=${ifDefined(this.label ? 'img' : undefined)}\n        aria-label=${ifDefined(this.label || undefined)}\n        aria-hidden=${ifDefined(this.label ? undefined : 'true')}\n      >\n        <use href=\"${DEFAULT_PATH}#arc-${this.name}\" xlink:href=\"${DEFAULT_PATH}#arc-${this.name}\" />\n      </svg>\n    `;\n    }\n}\nArcIcon.tag = 'arc-icon';\nArcIcon.styles = styles;\n__decorate([\n    property({ type: String, reflect: true })\n], ArcIcon.prototype, \"name\", void 0);\n__decorate([\n    property({ type: String })\n], ArcIcon.prototype, \"label\", void 0);\n__decorate([\n    property({ type: String, reflect: true })\n], ArcIcon.prototype, \"size\", void 0);\n__decorate([\n    property({ type: Number })\n], ArcIcon.prototype, \"rotation\", void 0);\n", "import ArcIcon from './ArcIcon.js';\ncustomElements.define('arc-icon', ArcIcon);\n", "import { css } from 'lit';\nimport componentStyles from '../../styles/component.styles.js';\nexport default [\n    componentStyles,\n    css `\n  :host {\n    --stroke-color: rgb(var(--arc-font-color));\n    --track-width: 2px;\n\n    display: inline-flex;\n    width: 1em;\n    height: 1em;\n  }\n\n  #main {\n    flex: 1 1 auto;\n    height: 100%;\n    width: 100%;\n  }\n\n  #track,\n  #indicator {\n    fill: none;\n    stroke-width: var(--track-width);\n    r: calc(0.5em - var(--track-width) / 2);\n    transform-origin: 50% 50%;\n  }\n\n  #track {\n    stroke: rgba(var(--arc-grey-050), 0.3););\n    transform-origin: 0 0;\n  }\n\n  #indicator {\n    stroke: var(--stroke-color);\n    stroke-linecap: round;\n    transform-origin: 50% 50%;\n    transform: rotate(90deg);\n    animation: spin 2.5s linear infinite;\n  }\n\n  @keyframes spin {\n    0% {\n      stroke-dasharray: 0.2em 3em;\n      transform: rotate(0deg);\n    }\n\n    50% {\n      stroke-dasharray: 2.2em 3em;\n      transform: rotate(450deg);\n    }\n\n    100% {\n      stroke-dasharray: 0.2em 3em;\n      transform: rotate(1080deg);\n    }\n  }\n`,\n];\n", "import { html, LitElement } from 'lit';\nimport styles from './arc-spinner.styles.js';\nexport default class ArcSpinner extends LitElement {\n    render() {\n        return html `\n      <svg id=\"main\" aria-busy=\"true\" aria-live=\"polite\">\n        <circle id=\"track\" cx=\"0.5em\" cy=\"0.5em\" r=\"0\" />\n        <circle id=\"indicator\" cx=\"0.5em\" cy=\"0.5em\" r=\"0\" />\n      </svg>\n    `;\n    }\n}\nArcSpinner.tag = 'arc-spinner';\nArcSpinner.styles = styles;\n", "import ArcSpinner from './ArcSpinner.js';\ncustomElements.define('arc-spinner', ArcSpinner);\n", "import { __decorate } from \"tslib\";\nimport { LitElement } from 'lit';\nimport { html, literal } from 'lit/static-html.js';\nimport { property, query } from 'lit/decorators.js';\nimport { when } from 'lit/directives/when.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport styles from './arc-icon-button.styles.js';\nimport '../icon/arc-icon.js';\nimport '../spinner/arc-spinner.js';\nexport default class ArcIconButton extends LitElement {\n    constructor() {\n        super(...arguments);\n        this.label = '';\n        this.active = false;\n        this.disabled = false;\n        this.loading = false;\n    }\n    click() {\n        this.button.click();\n    }\n    focus(options) {\n        this.button.focus(options);\n    }\n    blur() {\n        this.button.blur();\n    }\n    _handleClick(event) {\n        if (this.disabled || this.loading) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    }\n    render() {\n        const isLink = !!this.href;\n        const tag = isLink ? literal `a` : literal `button`;\n        return html `\n      <${tag}\n        id=\"main\"\n        class=${classMap({\n            button: true,\n            'button--active': this.active,\n            'button--disabled': this.disabled,\n            'button--loading': this.loading,\n        })}\n        ?disabled=${ifDefined(isLink ? undefined : this.disabled)}\n        type=\"button\"\n        href=${ifDefined(this.href || undefined)}\n        target=${ifDefined(this.target || undefined)}\n        download=${ifDefined(this.download || undefined)}\n        rel=${ifDefined(this.target ? 'noreferrer noopener' : undefined)}\n        role=\"button\"\n        aria-disabled=${this.disabled ? 'true' : 'false'}\n        aria-label=${this.label}\n        tabindex=${this.disabled ? '-1' : '0'}\n        @click=${this._handleClick}\n      >\n        <span id=\"iconWrapper\" aria-hidden=\"true\">\n          <arc-icon id=\"icon\" part=\"icon\" name=${ifDefined(this.name || undefined)}></arc-icon>\n          ${when(this.loading, () => html `<arc-spinner id=\"loader\"></arc-spinner>`)}\n        </span>\n        <span id=\"action\"><slot></slot></span>\n      </${tag}>\n    `;\n    }\n}\nArcIconButton.tag = 'arc-icon-button';\nArcIconButton.styles = styles;\n__decorate([\n    query('#main')\n], ArcIconButton.prototype, \"button\", void 0);\n__decorate([\n    property({ type: String })\n], ArcIconButton.prototype, \"name\", void 0);\n__decorate([\n    property({ type: String })\n], ArcIconButton.prototype, \"href\", void 0);\n__decorate([\n    property({ type: String })\n], ArcIconButton.prototype, \"target\", void 0);\n__decorate([\n    property({ type: String })\n], ArcIconButton.prototype, \"download\", void 0);\n__decorate([\n    property({ type: String })\n], ArcIconButton.prototype, \"label\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], ArcIconButton.prototype, \"active\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], ArcIconButton.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], ArcIconButton.prototype, \"loading\", void 0);\n", "import ArcIconButton from './ArcIconButton.js';\ncustomElements.define('arc-icon-button', ArcIconButton);\n", "const candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]:not(slot)',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n  'details>summary:first-of-type',\n  'details',\n];\nconst candidateSelector = /* #__PURE__ */ candidateSelectors.join(',');\n\nconst NoElement = typeof Element === 'undefined';\n\nconst matches = NoElement\n  ? function () {}\n  : Element.prototype.matches ||\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.webkitMatchesSelector;\n\nconst getRootNode =\n  !NoElement && Element.prototype.getRootNode\n    ? (element) => element.getRootNode()\n    : (element) => element.ownerDocument;\n\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\nconst getCandidates = function (el, includeContainer, filter) {\n  let candidates = Array.prototype.slice.apply(\n    el.querySelectorAll(candidateSelector)\n  );\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidatesScope\n * @property {Element} scope contains inner candidates\n * @property {Element[]} candidates\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidatesScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidatesScope>}\n */\nconst getCandidatesIteratively = function (\n  elements,\n  includeContainer,\n  options\n) {\n  const candidates = [];\n  const elementsToCheck = Array.from(elements);\n  while (elementsToCheck.length) {\n    const element = elementsToCheck.shift();\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      const assigned = element.assignedElements();\n      const content = assigned.length ? assigned : element.children;\n      const nestedCandidates = getCandidatesIteratively(content, true, options);\n      if (options.flatten) {\n        candidates.push(...nestedCandidates);\n      } else {\n        candidates.push({\n          scope: element,\n          candidates: nestedCandidates,\n        });\n      }\n    } else {\n      // check candidate element\n      const validCandidate = matches.call(element, candidateSelector);\n      if (\n        validCandidate &&\n        options.filter(element) &&\n        (includeContainer || !elements.includes(element))\n      ) {\n        candidates.push(element);\n      }\n\n      // iterate over shadow content if possible\n      const shadowRoot =\n        element.shadowRoot ||\n        // check for an undisclosed shadow\n        (typeof options.getShadowRoot === 'function' &&\n          options.getShadowRoot(element));\n\n      const validShadowRoot =\n        !options.shadowRootFilter || options.shadowRootFilter(element);\n\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        const nestedCandidates = getCandidatesIteratively(\n          shadowRoot === true ? element.children : shadowRoot.children,\n          true,\n          options\n        );\n\n        if (options.flatten) {\n          candidates.push(...nestedCandidates);\n        } else {\n          candidates.push({\n            scope: element,\n            candidates: nestedCandidates,\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift(...element.children);\n      }\n    }\n  }\n  return candidates;\n};\n\nconst getTabindex = function (node, isScope) {\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    //\n    // isScope is positive for custom element with shadow root or slot that by default\n    // have tabIndex -1, but need to be sorted by document order in order for their\n    // content to be inserted in the correct position\n    if (\n      (isScope ||\n        /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) ||\n        node.isContentEditable) &&\n      isNaN(parseInt(node.getAttribute('tabindex'), 10))\n    ) {\n      return 0;\n    }\n  }\n\n  return node.tabIndex;\n};\n\nconst sortOrderedTabbables = function (a, b) {\n  return a.tabIndex === b.tabIndex\n    ? a.documentOrder - b.documentOrder\n    : a.tabIndex - b.tabIndex;\n};\n\nconst isInput = function (node) {\n  return node.tagName === 'INPUT';\n};\n\nconst isHiddenInput = function (node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nconst isDetailsWithSummary = function (node) {\n  const r =\n    node.tagName === 'DETAILS' &&\n    Array.prototype.slice\n      .apply(node.children)\n      .some((child) => child.tagName === 'SUMMARY');\n  return r;\n};\n\nconst getCheckedRadio = function (nodes, form) {\n  for (let i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nconst isTabbableRadio = function (node) {\n  if (!node.name) {\n    return true;\n  }\n  const radioScope = node.form || getRootNode(node);\n  const queryRadios = function (name) {\n    return radioScope.querySelectorAll(\n      'input[type=\"radio\"][name=\"' + name + '\"]'\n    );\n  };\n\n  let radioSet;\n  if (\n    typeof window !== 'undefined' &&\n    typeof window.CSS !== 'undefined' &&\n    typeof window.CSS.escape === 'function'\n  ) {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error(\n        'Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s',\n        err.message\n      );\n      return false;\n    }\n  }\n\n  const checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nconst isRadio = function (node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nconst isNonTabbableRadio = function (node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\nconst isZeroArea = function (node) {\n  const { width, height } = node.getBoundingClientRect();\n  return width === 0 && height === 0;\n};\nconst isHidden = function (node, { displayCheck, getShadowRoot }) {\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  const isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  const nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n  const nodeRootHost = getRootNode(node).host;\n  const nodeIsAttached =\n    nodeRootHost?.ownerDocument.contains(nodeRootHost) ||\n    node.ownerDocument.contains(node);\n\n  if (!displayCheck || displayCheck === 'full') {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      const originalNode = node;\n      while (node) {\n        const parentElement = node.parentElement;\n        const rootNode = getRootNode(node);\n        if (\n          parentElement &&\n          !parentElement.shadowRoot &&\n          getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n\n      node = originalNode;\n    }\n    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n    if (nodeIsAttached) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    }\n\n    // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  }\n\n  // visible, as far as we can tell, or per current `displayCheck` mode\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nconst isDisabledFromFieldset = function (node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    let parentNode = node.parentElement;\n    // check if `node` is contained in a disabled <fieldset>\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (let i = 0; i < parentNode.children.length; i++) {\n          const child = parentNode.children.item(i);\n          // when the first <legend> (in document order) is found\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *')\n              ? true\n              : !child.contains(node);\n          }\n        }\n        // the disabled <fieldset> containing `node` has no <legend>\n        return true;\n      }\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\n\nconst isNodeMatchingSelectorFocusable = function (options, node) {\n  if (\n    node.disabled ||\n    isHiddenInput(node) ||\n    isHidden(node, options) ||\n    // For a details element with a summary, the summary element gets the focus\n    isDetailsWithSummary(node) ||\n    isDisabledFromFieldset(node)\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst isNodeMatchingSelectorTabbable = function (options, node) {\n  if (\n    isNonTabbableRadio(node) ||\n    getTabindex(node) < 0 ||\n    !isNodeMatchingSelectorFocusable(options, node)\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst isValidShadowRootTabbable = function (shadowHostNode) {\n  const tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  }\n  // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n  return false;\n};\n\n/**\n * @param {Array.<Element|CandidatesScope>} candidates\n * @returns Element[]\n */\nconst sortByOrder = function (candidates) {\n  const regularTabbables = [];\n  const orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    const isScope = !!item.scope;\n    const element = isScope ? item.scope : item;\n    const candidateTabindex = getTabindex(element, isScope);\n    const elements = isScope ? sortByOrder(item.candidates) : element;\n    if (candidateTabindex === 0) {\n      isScope\n        ? regularTabbables.push(...elements)\n        : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements,\n      });\n    }\n  });\n\n  return orderedTabbables\n    .sort(sortOrderedTabbables)\n    .reduce((acc, sortable) => {\n      sortable.isScope\n        ? acc.push(...sortable.content)\n        : acc.push(sortable.content);\n      return acc;\n    }, [])\n    .concat(regularTabbables);\n};\n\nconst tabbable = function (el, options) {\n  options = options || {};\n\n  let candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isValidShadowRootTabbable,\n    });\n  } else {\n    candidates = getCandidates(\n      el,\n      options.includeContainer,\n      isNodeMatchingSelectorTabbable.bind(null, options)\n    );\n  }\n  return sortByOrder(candidates);\n};\n\nconst focusable = function (el, options) {\n  options = options || {};\n\n  let candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot,\n    });\n  } else {\n    candidates = getCandidates(\n      el,\n      options.includeContainer,\n      isNodeMatchingSelectorFocusable.bind(null, options)\n    );\n  }\n\n  return candidates;\n};\n\nconst isTabbable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\n\nconst focusableCandidateSelector = /* #__PURE__ */ candidateSelectors\n  .concat('iframe')\n  .join(',');\n\nconst isFocusable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { tabbable, focusable, isTabbable, isFocusable };\n", "import { isTabbable } from 'tabbable';\nfunction getTabbableBoundary(root) {\n    const allElements = [];\n    function walk(el) {\n        if (el instanceof HTMLElement) {\n            allElements.push(el);\n            if (el.shadowRoot && el.shadowRoot.mode === 'open') {\n                walk(el.shadowRoot);\n            }\n        }\n        [...el.querySelectorAll('*')].map((e) => walk(e));\n    }\n    walk(root);\n    const start = allElements.find(el => isTabbable(el)) || null;\n    const end = allElements.reverse().find(el => isTabbable(el)) || null;\n    return { start, end };\n}\nexport { getTabbableBoundary };\n"],
  "mappings": "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",
  "names": ["html", "svg", "html", "candidateSelectors", "candidateSelector", "join", "NoElement", "Element", "matches", "prototype", "msMatchesSelector", "webkitMatchesSelector", "getRootNode", "element", "ownerDocument", "getTabindex", "node", "isScope", "tabIndex", "test", "tagName", "isContentEditable", "isNaN", "parseInt", "getAttribute", "isInput", "node", "tagName", "isHiddenInput", "type", "isDetailsWithSummary", "r", "Array", "prototype", "slice", "apply", "children", "some", "child", "getCheckedRadio", "nodes", "form", "i", "length", "checked", "isTabbableRadio", "name", "radioScope", "getRootNode", "queryRadios", "querySelectorAll", "radioSet", "window", "CSS", "escape", "err", "console", "error", "message", "isRadio", "isNonTabbableRadio", "isZeroArea", "getBoundingClientRect", "width", "height", "isHidden", "displayCheck", "getShadowRoot", "getComputedStyle", "visibility", "isDirectSummary", "matches", "call", "nodeUnderDetails", "parentElement", "nodeRootHost", "host", "nodeIsAttached", "ownerDocument", "contains", "originalNode", "rootNode", "shadowRoot", "assignedSlot", "getClientRects", "isDisabledFromFieldset", "test", "parentNode", "disabled", "item", "isNodeMatchingSelectorFocusable", "options", "isNodeMatchingSelectorTabbable", "getTabindex", "isTabbable", "node", "options", "Error", "matches", "call", "candidateSelector", "isNodeMatchingSelectorTabbable", "focusableCandidateSelector", "candidateSelectors", "concat", "join"]
}
